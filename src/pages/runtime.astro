---
import { Benchmark } from "../components/react/Benchmark"
import Layout from "../layouts/Layout.astro"
import { pub } from "../script/config"
import LnCache from "../components/LnCache.astro"
import StackVsHeap from "../components/StackVsHeap.astro"
import Code from "../components/Code.astro"
import Link from "../components/Link.astro"
---

<Layout title="Runtime">
    <h2>Profiler</h2>
    <p>
        Ein Profiler ist ein Werkzeug, das Software analysiert, um zu sehen, wie effizient sie läuft. Es misst, wie viel
        Zeit und Ressourcen verschiedene Teile des Codes verbrauchen. Das hilft Entwicklern zu verstehen, welche Teile
        des Programms verbessert werden müssen, um die Gesamtleistung zu steigern.
    </p>
    <h3>IntelliJ</h3>
    <video src={pub("/video/intellij-profiler.webm")} muted controls class="mx-auto aspect-auto w-full max-w-3xl"
    ></video>
    <h3>Flame Graph</h3>
    <p>
        Ein Flame Graph ist ein visuelles Werkzeug, das verwendet wird, um die Leistung eines Programms zu analysieren,
        insbesondere um zu sehen, welche Teile des Codes die meiste Zeit in Anspruch nehmen.
    </p>
    <p>
        Ein Flame Graph besteht aus einer Reihe von farbigen Rechtecken, die in Schichten übereinander gestapelt sind.
        Jedes Rechteck repräsentiert eine Funktion oder Methode, die in deinem Programm aufgerufen wird. Die Breite
        eines Rechtecks zeigt an, wie viel Zeit diese Funktion im Vergleich zu anderen Funktionen in Anspruch nimmt. Je
        breiter das Rechteck, desto mehr Zeit wird in dieser Funktion verbracht.
    </p>
    <div style={`min-height: calc(24em + 200px)`}>
        <Benchmark client:visible client:only="react" />
    </div>

    <h2>Benchmarking</h2>
    <p>
        Bevor du irgendwelche Änderungen vornimmst, solltest du einen Benchmark durchführen. Für Java gibt es
        beispielsweise JMH (Java Microbenchmark Harness).
    </p>
    <p>Hier der Gradle Code für JMH:</p>
    <Code
        language="groovy"
        code={`
plugins {
    id "me.champeau.jmh" version "0.7.2"
}

sourceSets {
    jmh {
        java {
            srcDirs = ['src/jmh/java']
        }
    }
}

dependencies {
    jmh 'org.openjdk.jmh:jmh-core:1.37'
    jmh 'org.openjdk.jmh:jmh-generator-annprocess:1.37'
    jmh 'org.openjdk.jmh:jmh-generator-bytecode:1.37'
}
        `}
    />

    <h2>Contiguous Memory</h2>
    <LnCache />
    <h2>Stack & Heap</h2>
    <StackVsHeap />
    <h2>Daten&shy;kompression</h2>
    <p>
        Bei rießigen Datenmengen ist es oft sinnvoll, diese zu komprimieren, um Speicherplatz zu sparen. Hierbei geht es
        um grundlegende Techniken der Informatik wie
        <Link href="https://youtu.be/JsTptu56GM8">Huffman-Coding</Link>
        oder
        <Link href="https://youtu.be/RON2FmNrR58">Karnaugh map (KV-Diagramm) </Link>
        .
    </p>
    <p>
        Bei diesen Techniken arbeitet man meist mit einzelnen Bits. Jedoch gibt es in keiner Programmiersprache einen
        Datentyp für einzelne Bits. Das liegt daran, dass die CPU nur auf Byte-Ebene arbeitet. Ein Bit hat keine Adresse
        (Pointer) im Arbeitsspeicher.
    </p>
    <p>
        Bei kleinen Datenmengen kann man primitive Ganzzahl-Typen (in Java <code>int</code>(32 Bit) und <code>long</code
        >(64 Bit)) verwenden.
    </p>
    <Code
        code={`
public class Main {
    public static void main(String[] args) {
        int bits = 0; // 8 Byte 32 bit
        System.out.println(Integer.toBinaryString(bits));

        // setze das 3. Bit von rechts auf 1
        bits |= 0b100;
        System.out.println(Integer.toBinaryString(bits));

        // setze das 4. Bit von rechts auf 1
        bits |= 0b1 << 3; // 0b1 bitshift um 3 Stellen nach links -> 0b1000
        System.out.println(Integer.toBinaryString(bits));

        // invertiere alle Bits
        bits = ~bits;
        System.out.println(Integer.toBinaryString(bits));

        // Schiebe alle Bits um 2 Stellen nach rechts
        bits >>= 2;
        System.out.println(Integer.toBinaryString(bits));
    }
}
`}
    />
    <p>
        Bei größeren Datenmengen gibt es verschiedene Möglichkeiten je nach Programmiersprache. Java bietet den Datentyp
        <code>BitSet</code> an.
    </p>
    <Code
        code={`
import java.util.BitSet;

public class Main {
    public static void main(String[] args) {
        BitSet bits = new BitSet(32); // 32 bit
        printBitSet(bits);

        // setze das 3. Bit von rechts auf 1
        bits.set(2); // BitSet ist nullbasiert, daher Index 2
        printBitSet(bits);

        // setze das 4. Bit von rechts auf 1
        bits.set(3);
        printBitSet(bits);

        // invertiere alle Bits
        bits.flip(0, bits.length());
        printBitSet(bits);

        // Schiebe alle Bits um 2 Stellen nach rechts
        bits = bits.get(2, bits.length());
        printBitSet(bits);
    }

    private static void printBitSet(BitSet bitSet) {
        StringBuilder binaryString = new StringBuilder();
        for (int i = 0; i < 32; i++) {
            binaryString.append(bitSet.get(i) ? "1" : "0");
        }
        System.out.println(binaryString.reverse());
    }
}
    `}
    />
    <h2>Syscalls</h2>
    <p>
        Syscalls sind Anfragen an das Betriebssystem, um bestimmte Aufgaben zu erledigen, die das Programm selbst nicht
        kann. Dazu gehören das Lesen und Schreiben von Dateien (Festplattenzugriff) oder den <Link
            href="https://en.wikipedia.org/wiki/Standard_streams">Standard streams</Link
        >, das Erstellen von Prozessen, das Erstellen von Netzwerkverbindungen und das Verwalten von Speicher
        (Arbeitsspeicher).
    </p>
    <p>
        Mehr Infos dazu gibt es indem Video
        <Link href="https://youtu.be/UW7a1n3VEFg">System calls at the assembly level von Artem Pianykh </Link>
        .
    </p>
    <p>
        Syscalls sind langsam. Deshalb ist es wichtig, Syscalls zu minimieren, um die Leistung des Programms zu
        verbessern.
    </p>
</Layout>
